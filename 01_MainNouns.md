## 摘要
webpack整个体系非常庞大，要透彻的认识和理解他确实需要一定的耐心和精力，同时还需要一点认知的技巧。在这里建议我们从全局到局部逐步地去掌握他。先大体了解一些概念，然后一个模块一个模块逐步分解地去了解。

这一节，我们先熟悉一些webpack中高频名词，这些是个人理解的总结，后续章节中我们还会有详细地介绍。[官方文档](https://webpack.docschina.org/glossary)有相应的介绍，不过略抽象一些，大家也可以对比着去看。

## 关键词解释
1. loader(翻译官)
webpack自身只理解Javascript，loader可以将非JS文件“翻译”为webpack能够处理的模块。


2. plugin(插件)
插件可以执行一系列的任务，webpack的整个生态系统可以说都是由插件构建起来的，通过插件，我们可以触达webpack生命周期中的每个节点，进而扩展编译功能。


3. 依赖关系图(“家谱”)
webpack的打包不是盲目进行的，它会通过入口文件获取打包的线索，这个线索就是我们程序代码里边所有模块或资源的依赖关系。


4. module(模块 —— 用户写出来的模块代码)
功能模块，是相对于整个应用程序更小粒度的封装。可能是一个函数、一段代码、一个文件。


5. chunk(文件 —— webpack处理过程中的js代码)
webpack根据文件的依赖关系情况（同步还是异步），决定是否需要把模块打包到同一个chunk中，这些经过内部处理生成的js代码就是chunk，一个chunk可能包含多个模块，其作用是优化异步加载。chunkId就是每个chunk文件唯一的id值，chunkhash是每个文件内容的md5值。传说中的代码分离(Code Splitting)就发生在这一步。


6. bundle(束 —— webpack最终生成的js文件)
chunk文件经过进一步处理，输出bundle文件，包含编译好的最终代码，可直接在浏览器上运行。通常一个chunk对应一个bundle，实际情况根据webpack配置来进行。


7. Tree Shaking(去除死代码)
“死代码”就是我们应用程序中用不到的多余的代码，比如我们只用了一个库中的某个接口，但是将整个库都引入了进来，显然webpack不应该把这些代码打包进去。该特性只针对ES6 modules生效，因为ES6模块的依赖查找是在编译时而不是运行时。最新的webpack版本(4以上)已经支持设置mode为production就默认会删除死代码。若工程中使用了babel-loader，则要禁用他的模块依赖解析，因为他转化过的都是CommonJS形式的模块，导致无法利用tree shaking特性。 


8. source-map(映射表)
源代码和经过处理后生成代码之间的映射，方便我们调试，支持十几种配置方式，可以通过多种不同的方式获取这种映射信息。


9. Long Time Cache(长缓存)
浏览器共服务器加载资源的时候，可以根据head头部设置信息，对资源进行缓存处理，再次访问就不需要从服务器拿而是直接从缓存中取，从而加快访问速度。webpack打包出来的chunk文件名，均有一个chunkhash值，它是基于文件内容生成的哈希值，只有在内容更新的情况下才会改变，但公共库文件一般是不会改变的，它使得页面可以充分利用浏览器缓存，同时又能拿到更新过的最新文件。因此，我们可以通过抽离第三方库和公共代码、固定模块标识符等方式来使用使用长缓存。


10. 懒加载(按需加载)
页面没有必要在一开始把项目所有的资源都加载完，而是在触发了某些操作，或在需要的时候才会去加载某些模块，这样可以加快页面初次加载的速度，减小页面体积。


11. 热更新(HMR)
这个是webpack提供的优化开发体验的特性。使得我们当时写的代码可以即时地更新到页面上，而不需要我们手动重复地刷新页面。webpack可以在不刷新页面的情况下去替换、删除、更新模块，大大提升了开发效率。


12. webpack
简单地说就是一个打包工具，但这是一个功能很强大，支持高度可配置、可扩展的模块打包器。
